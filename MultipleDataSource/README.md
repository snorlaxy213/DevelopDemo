### 为什么要分表分库

主要为了处理大数据量和高并发问题。

### 如何对数据库进行垂直拆分和水平拆分

垂直拆分：把一个表的数据给拆分成多个表或者多个库上，每个库表的结构不同，每个库表都包含部分字段。**一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。**
因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。

水平拆分：把一个表的数据拆分到多个库的多个表上，但是每个库的表结构一样，数据不一样，所有库的表的数据加起来就是全部数据。**水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。**

### 分表分库的方式

- 一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。

- 按照某个字段 hash 一下均匀分散。

range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。

hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。

### 分表分库ID怎么处理？

DistributeController: demo介绍和想法

### 如何设计动态扩容缩容的分表分库方案？（如何处理ID扩容的问题）

表思路设计：

Group：

| column     | type    |
| ---------- | ------- |
| group_id   | int     |
| group_name | varchar |
| start_id   | int     |
| end_id     | int     |

| group_id | group_name | start_id | end_id   |
| -------- | ---------- | -------- | -------- |
| 1        | group01    | 0        | 40000000 |
| 2        | group02    | 40000000 | 80000000 |

DB：

| column     | type    |
| ---------- | ------- |
| db_id      | int     |
| db_name    | varchar |
| group_id   | int     |
| hash_value | int     |

| db_id | db_name  | group_id | hash_value |
| ----- | -------- | -------- | ---------- |
| 1     | g01_db_0 | 1        | 0,1,2,3    |
| 2     | g01_db_1 | 1        | 4,5,6      |
| 3     | g01_db_2 | 1        | 7,8,9      |
| 4     | g02_db_0 | 2        | 0,1,2      |
| 5     | g02_db_1 | 2        | 3,4,5      |
| 6     | g02_db_2 | 2        | 6,7,8      |

Table:

| column     | type    |
| ---------- | ------- |
| table_id   | int     |
| table_name | varchar |
| db_id      | int     |
| start_id   | int     |
| end_id     | int     |

| table_id | table_name | db_id | start_id | end_id  |
| -------- | ---------- | ----- | -------- | ------- |
| 1        | table0     | 1     | 0        | 1000000 |
| 2        | table1     | 1     | 1000000  | 2000000 |
|          | table2     | 1     | 2000000  | 3000000 |
| 4        | table3     | 1     | 3000000  | 4000000 |
| 5        | table4     | 2     | 0        | 1000000 |
| 6        | table5     | 2     | 1000000  | 2500000 |
| 7        | table6     | 2     | 2500000  | 4000000 |
| 8        | table7     | 3     | 0        | 1000000 |
| 9        | table8     | 3     | 1000000  | 2500000 |
| 10       | table9     | 3     | 2500000  | 4000000 |
| 11       | table10    | 4     | 4000000  | 5500000 |
| 12       | table12    | 4     | 5500000  | 7000000 |
| 13       | table12    | 4     | 7000000  | 8000000 |
| 14       | table13    | 5     | 4000000  | 5500000 |
| 15       | table14    | 5     | 5500000  | 7000000 |
| 16       | table15    | 5     | 7000000  | 8000000 |
| 17       | table16    | 6     | 4000000  | 5500000 |
|          | table17    | 6     | 5500000  | 7000000 |
| 19       | table18    | 6     | 7000000  | 8000000 |

Tips:

把配置关系存到本地JVM缓存，实现不重启即可更新配置关系；

本地JVM更新：zookeeper或者分布式配置中心；

