### 为什么要分表分库

主要为了处理大数据量和高并发问题。

### 如何对数据库进行垂直拆分和水平拆分

垂直拆分：把一个表的数据给拆分成多个表或者多个库上，每个库表的结构不同，每个库表都包含部分字段。**一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。**因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。

水平拆分：把一个表的数据拆分到多个库的多个表上，但是每个库的表结构一样，数据不一样，所有库的表的数据加起来就是全部数据。**水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。**

### 分表分库的方式

- 一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。

- 按照某个字段 hash 一下均匀分散。

range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。

hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。

### 分表分库后ID怎么处理

**基于数据库的实现方案**

1. 数据库自增id：简单易用，缺点是单库生成自增id，在高并发场景下有瓶颈。
   适用场景：并发不高，但是数据量太大导致的分表分库。
2. 设置数据库sequence或者自增字段步长
   适用场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。

**UUID**

优点：本地生成，不会基于数据库；

缺点：

	1. UUID太长，占用空间太多 ，作为主键性能很差；
 	2. UUID不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写）；

适用场景：文件名、编号。。。。

**系统当前时间**

单独使用时，并发量很高（1s几千）的时候，会有重复的情况，***基本不会考虑***

适用场景：配合某个字段可以组成全局唯一ID（业务上可接受的话也可以做）。

**snowflake算法**

snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号。